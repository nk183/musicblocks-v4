{"version":3,"sources":["components/editor/core/index.ts"],"names":["generateAPI","snapshot","getSpecificationSnapshot","api","Object","entries","filter","specification","type","includes","category","forEach","elementName","instanceID","addInstance","instance","getInstance","args","argLabels","map","arg","getArgType","join","removeInstance","push","name","types","buildProgram","code","Promise","resolve","lines","split","units","length","checkValidity","generateSnapshot","process","routine","crumbs","crumb","addInstruction","argMap","slice","unit","param","value","generateFromSnapshot","transpile","e","console","log","resetProgram","resetSyntaxTree","registerElementSpecificationEntries","librarySpecification"],"mappings":"6RA0BO,SAASA,IACZ,IAAMC,EAAWC,qCACXC,EAAgB,GAoBtB,OAlBAC,OAAOC,QAAQJ,GACVK,QACG,mCAAKC,GAAL,iBAC2B,cAAvBA,EAAcC,MACd,CAAC,WAAY,OAAOC,SAASF,EAAcG,aAElDC,SAAQ,YAAuB,IAAD,mBAApBC,EAAoB,KACrBC,GADqB,KACRC,sBAAYF,IACzBG,EAAWC,sBAAYH,GAAaE,SACpCE,EAA2BF,EAASG,UAAUC,KAAI,SAACC,GAAD,MAAS,CAC7DA,EACAL,EAASM,WAAWD,GAAKE,KAAK,SAElCC,yBAAeV,GAEfV,EAAIqB,KAAJ,UAAYZ,EAAZ,YAA2BK,EAAKE,KAAI,mCAAEM,EAAF,KAAQC,EAAR,qBAAsBD,EAAtB,YAA8BC,MAASJ,KAAK,UAGjFnB,EAAImB,KAAK,MAQb,SAASK,EAAaC,GA2DzB,OAAO,IAAIC,SAAQ,SAACC,GAChB,IAAwB,IA3D5B,WAII,IAJ8B,EAIxBC,EAAQH,EAAKI,MAAM,MAJK,cAKXD,GALW,IAK9B,2BAA0B,CAAC,IACjBE,EADgB,QACHD,MAAM,KACzB,GAEyB,IAAjBC,EAAMC,QACW,IAAjBD,EAAMC,QACW,IAAjBD,EAAMC,SACY,IAAjBD,EAAMC,QAA6B,KAAbD,EAAM,IAA0B,KAAbA,EAAM,IAGpD,OAAO,GAfe,8BAmB9B,OAAO,EAwCHE,GACAL,GAAQ,OACL,CACH,IAAM7B,EAAWmC,6BACjB,KAzCR,WAII,IAJuB,EAIjBnC,EAA+B,CAAEoC,QAAS,GAAIC,QAAS,GAAIC,OAAQ,CAAC,KACpEC,EAAQvC,EAASsC,OAAO,GAExBE,EAAiB,SAACR,GACpB,IAAMrB,EAAcqB,EAAM,GACpBS,EAAS,GAEgBT,EAC1BU,MAAM,GACNxB,KAAI,SAACyB,GAAD,OAAUA,EAAKZ,MAAM,QACzBrB,SAAQ,YAAqB,IAAD,mBAAlBkC,EAAkB,KAAXC,EAAW,KAE7BJ,EAAOG,GAAS,CACZjC,YAAa,eACbkC,YAIRN,EAAMhB,KAAK,CACPZ,cACA8B,YAxBe,cA4BJd,EAAKI,MAAM,OA5BP,IA4BvB,2BAEIS,EAFiC,QACdT,MAAM,MA7BN,8BAiCvBe,+BAAqB9C,GASb+C,GACAlB,GAAQ,GACV,MAAOmB,GACLC,QAAQC,IAAIF,GACZF,+BAAqB9C,GACrB6B,GAAQ,QASjB,SAASsB,IACZC,4BAtHJC,8CAAoCC","file":"static/js/11.ffaceb0a.chunk.js","sourcesContent":["/* eslint-disable @typescript-eslint/ban-ts-comment */\n\nimport {\n    ITreeSnapshotInput,\n    generateFromSnapshot,\n    generateSnapshot,\n    registerElementSpecificationEntries,\n    resetSyntaxTree,\n    getSpecificationSnapshot,\n} from '@sugarlabs/musicblocks-v4-lib';\n\nimport {\n    addInstance,\n    getInstance,\n    removeInstance,\n} from '@sugarlabs/musicblocks-v4-lib/syntax/warehouse/warehouse';\n\nimport { librarySpecification } from '@sugarlabs/musicblocks-v4-lib';\nregisterElementSpecificationEntries(librarySpecification);\n\n// -- public functions -----------------------------------------------------------------------------\n\n/**\n * Generates the API for the loaded specification.\n * @returns list of valid instruction signatures\n */\nexport function generateAPI(): string {\n    const snapshot = getSpecificationSnapshot();\n    const api: string[] = [];\n\n    Object.entries(snapshot)\n        .filter(\n            ([_, specification]) =>\n                specification.type === 'Statement' &&\n                ['Graphics', 'Pen'].includes(specification.category),\n        )\n        .forEach(([elementName, _]) => {\n            const instanceID = addInstance(elementName);\n            const instance = getInstance(instanceID)!.instance;\n            const args: [string, string][] = instance.argLabels.map((arg) => [\n                arg,\n                instance.getArgType(arg).join('|'),\n            ]);\n            removeInstance(instanceID);\n\n            api.push(`${elementName} ${args.map(([name, types]) => `${name}:${types}`).join(' ')}`);\n        });\n\n    return api.join('\\n');\n}\n\n/**\n * Validates code, transpiles it, and generates the Syntax Tree in the Programming Engine.\n * @param code editor's code\n * @returns a `Promise` that returns whether the process was successful\n */\nexport function buildProgram(code: string): Promise<boolean> {\n    function checkValidity(): boolean {\n        /*\n         * dummy logic\n         */\n        const lines = code.split('\\n');\n        for (const line of lines) {\n            const units = line.split(' ');\n            if (\n                !(\n                    units.length === 1 ||\n                    units.length === 2 ||\n                    units.length === 3 ||\n                    (units.length === 4 && units[0] === '' && units[1] === '')\n                )\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function transpile(): void {\n        // dummy program build (for debugging)\n        // import('./dummy');\n\n        const snapshot: ITreeSnapshotInput = { process: [], routine: [], crumbs: [[]] };\n        const crumb = snapshot.crumbs[0];\n\n        const addInstruction = (units: string[]) => {\n            const elementName = units[0];\n            const argMap = {};\n\n            let args: [string, string][] = units\n                .slice(1)\n                .map((unit) => unit.split(':') as [string, string]);\n            args.forEach(([param, value]) => {\n                // @ts-ignore\n                argMap[param] = {\n                    elementName: 'value-number',\n                    value,\n                };\n            });\n\n            crumb.push({\n                elementName,\n                argMap,\n            });\n        };\n\n        for (const line of code.split('\\n')) {\n            const units = line.split(' ');\n            addInstruction(units);\n        }\n\n        generateFromSnapshot(snapshot);\n    }\n\n    return new Promise((resolve) => {\n        if (checkValidity() === false) {\n            resolve(false);\n        } else {\n            const snapshot = generateSnapshot();\n            try {\n                transpile();\n                resolve(true);\n            } catch (e) {\n                console.log(e);\n                generateFromSnapshot(snapshot);\n                resolve(false);\n            }\n        }\n    });\n}\n\n/**\n * Resets the program â€” generates an empty Syntax Tree.\n */\nexport function resetProgram(): void {\n    resetSyntaxTree();\n}\n"],"sourceRoot":""}